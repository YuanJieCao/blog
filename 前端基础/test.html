<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

<script>
    class Node {
        constructor(key) {
            this.key = key;
            this.left = null;
            this.right = null;
        }
    }

    function defaultCompare(a, b) {
        return a < b ? "Compare.LESS_THAN" : "Compare.BIGGER_THAN"
    }

    class BinarySearchTree {
        constructor(compareFn = defaultCompare) {
            this.compareFn = compareFn;
            this.root = null;
        }

        insert(key) {
            if (this.root == null) {
                this.root = new Node(key);
            } else {
                this.insertNode(this.root, key);
            }
        }

        insertNode(node, key) {
            if (this.compareFn(key, node.key) === "Compare.LESS_THAN") {
                if (node.left == null) {
                    node.left = new Node(key);
                } else {
                    this.insertNode(node.left, key);
                }
            } else {
                if (node.right == null) {
                    node.right = new Node(key);
                } else {
                    this.insertNode(node.right, key);
                }
            }
        }

        removeNode(node, key) {
            if (node == null) { // {2}
                return null;
            }
            if (this.compareFn(key, node.key) === Compare.LESS_THAN) { // {3}
                node.left = this.removeNode(node.left, key); // {4}
                return node; // {5}
            } else if (
                this.compareFn(key, node.key) === Compare.BIGGER_THAN
            ) { // {6}
                node.right = this.removeNode(node.right, key); // {7}
                return node; // {8}
            } else {
                // 键等于node.key
                // 第一种情况
                if (node.left == null && node.right == null) { // {9}
                    node = null; // {10}
                    return node; // {11}
                }
                // 第二种情况
                if (node.left == null) { // {12}
                    node = node.right; // {13}
                    return node; // {14}
                } else if (node.right == null) { // {15}
                    node = node.left; // {16}
                    return node; // {17}
                }
                // 第三种情况
                const aux = this.minNode(node.right); // {18}
                node.key = aux.key; // {19}
                node.right = this.removeNode(node.right, aux.key); // {20}
                return node; // {21}
            }
        }

        getNodeHeight(node) {
            if (node == null) {
                return -1;
            }
            console.log(node)
            return Math.max(
                this.getNodeHeight(node.left), this.getNodeHeight(node.right)
            ) + 1;
        }
    }


    const BalanceFactor = {
        UNBALANCED_RIGHT: 1,
        SLIGHTLY_UNBALANCED_RIGHT: 2,
        BALANCED: 3,
        SLIGHTLY_UNBALANCED_LEFT: 4,
        UNBALANCED_LEFT: 5
    };

    //平衡树 每一次插入删除需要检验平衡因子
    class AVLTree extends BinarySearchTree {

        constructor(compareFn = defaultCompare) {
            super(compareFn);
            this.compareFn = compareFn;
            this.root = null;
        }

        //传进去一个node
        getNodeHeight(node) {
            if (node == null) {
                return -1;
            }

            return Math.max(
                this.getNodeHeight(node.left), this.getNodeHeight(node.right)
            ) + 1;
        }

        getBalanceFactor(node) {

            const heightDifference = this.getNodeHeight(node.left) - this.getNodeHeight(node.right);
            switch (heightDifference) {
                case -2:
                    return BalanceFactor.UNBALANCED_RIGHT;
                case -1:
                    return BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT;
                case 1:
                    return BalanceFactor.SLIGHTLY_UNBALANCED_LEFT;
                case 2:
                    return BalanceFactor.UNBALANCED_LEFT;
                default:
                    return BalanceFactor.BALANCED;
            }
        }


        rotationLL(node) {
            //    肯定是哪一个节点的平衡因子改变了，然后针对他进行改变
            let temp = node.left
            node.left = temp.right
            temp.right = node
            return temp
        }

        //
        rotationRR(node) {
            let temp = node.right
            node.right = temp.left
            temp.left = node
            return temp
        }

//    左指数的右指数上
        rotationLR(node) {
            node.left = this.rotationRR(node.left);
            return this.rotationLL(node);

            // let temp = node.right //保存右边的节点
            // let len = node.left //保存左边的节点
            // let current = len.right//左边节点的右指数

        }

        rotationRL(node) {
            node.right = this.rotationLL(node.right)
            return this.rotationRR(node)
        }

        insert(key) {
            this.root = this.insertNode(this.root, key);
        }

        insertNode(node, key) {
            // 像在BST树中一样插入节点
            if (node == null) {
                return new Node(key);
            } else if (this.compareFn(key, node.key) === "Compare.LESS_THAN") {
                node.left = this.insertNode(node.left, key);
            } else if (this.compareFn(key, node.key) === "Compare.BIGGER_THAN") {
                node.right = this.insertNode(node.right, key);
            } else {
                return node; // 重复的键
            }
            // 如果需要，将树进行平衡操作
            const balanceFactor = this.getBalanceFactor(node); // {1}
            if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) { // {2}
                if (this.compareFn(key, node.left.key) === "Compare.LESS_THAN") { // {3}
                    node = this.rotationLL(node); // {4}
                } else {
                    return this.rotationLR(node); // {5}
                }
            }
            if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) { // {6}
                if (
                    this.compareFn(key, node.right.key) === "Compare.BIGGER_THAN"
                ) { // {7}
                    node = this.rotationRR(node); // {8}
                } else {
                    return this.rotationRL(node); // {9}
                }
            }
            return node;
        }

        removeNode(node, key) {
            node = super.removeNode(node, key); // {1}
            if (node == null) {
                return node; // null，不需要进行平衡
            }
            // 检测树是否平衡
            const balanceFactor = this.getBalanceFactor(node); // {2}
            if (balanceFactor === BalanceFactor.UNBALANCED_LEFT) { // {3}
                const balanceFactorLeft = this.getBalanceFactor(node.left); // {4}
                if (
                    balanceFactorLeft === BalanceFactor.BALANCED ||
                    balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
                ) { // {5}
                    return this.rotationLL(node); // {6}
                }
                if (
                    balanceFactorLeft === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
                ) { // {7}
                    return this.rotationLR(node.left); // {8}
                }
            }
            if (balanceFactor === BalanceFactor.UNBALANCED_RIGHT) { // {9}
                const balanceFactorRight = this.getBalanceFactor(node.right); // {10}
                if (
                    balanceFactorRight === BalanceFactor.BALANCED ||
                    balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_RIGHT
                ) { // {11}
                    return this.rotationRR(node); // {12}
                }
                if (
                    balanceFactorRight === BalanceFactor.SLIGHTLY_UNBALANCED_LEFT
                ) { // {13}
                    return this.rotationRL(node.right); // {14}
                }
            }
            return node;
        }


    }

    const AVLTreeNode = new AVLTree()
    AVLTreeNode.insert(10)
    AVLTreeNode.insert(9)
    AVLTreeNode.insert(8)
    AVLTreeNode.insert(7)
    AVLTreeNode.insert(14)
    AVLTreeNode.insert(15)
    AVLTreeNode.insert(16)
    AVLTreeNode.insert(18)
    AVLTreeNode.insert(18)

    console.log(AVLTreeNode)
</script>
</body>
</html>